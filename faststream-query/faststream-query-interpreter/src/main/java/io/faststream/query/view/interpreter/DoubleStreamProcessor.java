/*
 * Copyright (c) 2008 Kasper Nielsen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* 
 * This class was automatically generated by cake.bootstrap.view.GenerateAll 
 * Available in the https://github.com/cakeframework/cake-developers/ project 
 */
package io.faststream.query.view.interpreter;

/**
 * This class has been autogenerated
 *
 * @author Kasper Nielsen
 */
import java.util.Objects;
import java.util.OptionalDouble;
import java.util.stream.DoubleStream;

import io.faststream.query.db.nodes.stream.doublestream.DoubleStreamVisitable;
import io.faststream.query.db.nodes.stream.doublestream.SDT_AllMatch;
import io.faststream.query.db.nodes.stream.doublestream.SDT_AnyMatch;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Average;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Collect;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Count;
import io.faststream.query.db.nodes.stream.doublestream.SDT_FindAny;
import io.faststream.query.db.nodes.stream.doublestream.SDT_FindFirst;
import io.faststream.query.db.nodes.stream.doublestream.SDT_ForEach;
import io.faststream.query.db.nodes.stream.doublestream.SDT_ForEachOrdered;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Iterator;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Max;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Min;
import io.faststream.query.db.nodes.stream.doublestream.SDT_NoneMatch;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Reduce;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Spliterator;
import io.faststream.query.db.nodes.stream.doublestream.SDT_Sum;
import io.faststream.query.db.nodes.stream.doublestream.SDT_SummaryStatistics;
import io.faststream.query.db.nodes.stream.doublestream.SDT_ToArray;
import io.faststream.query.db.nodes.stream.doublestream.SD_Boxed;
import io.faststream.query.db.nodes.stream.doublestream.SD_Distinct;
import io.faststream.query.db.nodes.stream.doublestream.SD_Filter;
import io.faststream.query.db.nodes.stream.doublestream.SD_FlatMap;
import io.faststream.query.db.nodes.stream.doublestream.SD_Limit;
import io.faststream.query.db.nodes.stream.doublestream.SD_Map;
import io.faststream.query.db.nodes.stream.doublestream.SD_MapToInt;
import io.faststream.query.db.nodes.stream.doublestream.SD_MapToLong;
import io.faststream.query.db.nodes.stream.doublestream.SD_MapToObj;
import io.faststream.query.db.nodes.stream.doublestream.SD_Parallel;
import io.faststream.query.db.nodes.stream.doublestream.SD_Peek;
import io.faststream.query.db.nodes.stream.doublestream.SD_Sequential;
import io.faststream.query.db.nodes.stream.doublestream.SD_Skip;
import io.faststream.query.db.nodes.stream.doublestream.SD_Sorted;
import io.faststream.query.db.nodes.stream.doublestream.SD_Unordered;
import io.faststream.query.db.query.node.EmptyResult;
import io.faststream.query.db.query.node.QueryOperationNode;

@SuppressWarnings("unchecked" )
public class DoubleStreamProcessor extends AbstractSingleNodeViewQueryProcessor implements DoubleStreamVisitable.DoubleStreamVisitor {

    private final DoubleStream s;

    public DoubleStreamProcessor(DoubleStream s) {
        this.s = Objects.requireNonNull(s);
    }

    public void allMatch(SDT_AllMatch node) {
        setResult(s.allMatch(node.getDoublePredicate()));
    }

    public void anyMatch(SDT_AnyMatch node) {
        setResult(s.anyMatch(node.getDoublePredicate()));
    }

    public void average(SDT_Average node) {
        OptionalDouble opt = s.average();
        setResult(opt.isPresent() ? opt.getAsDouble() : EmptyResult.EMPTY_RESULT);
    }

    public void boxed(SD_Boxed node) {
        setNext(new StreamProcessor(s.boxed()));
    }

    public void collect(SDT_Collect node) {
        setResult(s.collect(node.getSupplier(), node.getObjDoubleConsumer(), node.getBiConsumer()));
    }

    public void count(SDT_Count node) {
        setResult(s.count());
    }

    public void distinct(SD_Distinct node) {
        setNext(new DoubleStreamProcessor(s.distinct()));
    }

    public void filter(SD_Filter node) {
        setNext(new DoubleStreamProcessor(s.filter(node.getDoublePredicate())));
    }

    public void findAny(SDT_FindAny node) {
        OptionalDouble opt = s.findAny();
        setResult(opt.isPresent() ? opt.getAsDouble() : EmptyResult.EMPTY_RESULT);
    }

    public void findFirst(SDT_FindFirst node) {
        OptionalDouble opt = s.findFirst();
        setResult(opt.isPresent() ? opt.getAsDouble() : EmptyResult.EMPTY_RESULT);
    }

    public void flatMap(SD_FlatMap node) {
        setNext(new DoubleStreamProcessor(s.flatMap(node.getMapper())));
    }

    public void forEach(SDT_ForEach node) {
        s.forEach(node.getAction());
        setResult(null);
    }

    public void forEachOrdered(SDT_ForEachOrdered node) {
        s.forEachOrdered(node.getAction());
        setResult(null);
    }

    public void iterator(SDT_Iterator node) {
        setResult(s.iterator());
    }

    public void limit(SD_Limit node) {
        setNext(new DoubleStreamProcessor(s.limit(node.getMaxSize())));
    }

    public void map(SD_Map node) {
        setNext(new DoubleStreamProcessor(s.map(node.getDoubleUnaryOperator())));
    }

    public void mapToInt(SD_MapToInt node) {
        setNext(new IntStreamProcessor(s.mapToInt(node.getMapper())));
    }

    public void mapToLong(SD_MapToLong node) {
        setNext(new LongStreamProcessor(s.mapToLong(node.getMapper())));
    }

    public void mapToObj(SD_MapToObj node) {
        setNext(new StreamProcessor(s.mapToObj(node.getMapper())));
    }

    public void max(SDT_Max node) {
        OptionalDouble opt = s.max();
        setResult(opt.isPresent() ? opt.getAsDouble() : EmptyResult.EMPTY_RESULT);
    }

    public void min(SDT_Min node) {
        OptionalDouble opt = s.min();
        setResult(opt.isPresent() ? opt.getAsDouble() : EmptyResult.EMPTY_RESULT);
    }

    public void noneMatch(SDT_NoneMatch node) {
        setResult(s.noneMatch(node.getDoublePredicate()));
    }

    public void parallel(SD_Parallel node) {
        setNext(new DoubleStreamProcessor(s.parallel()));
    }

    public void peek(SD_Peek node) {
        setNext(new DoubleStreamProcessor(s.peek(node.getDoubleConsumer())));
    }

    public void reduce(SDT_Reduce node) {
        OptionalDouble opt = s.reduce(node.getOp());
        setResult(opt.isPresent() ? opt.getAsDouble() : EmptyResult.EMPTY_RESULT);
    }

    public void sequential(SD_Sequential node) {
        setNext(new DoubleStreamProcessor(s.sequential()));
    }

    public void skip(SD_Skip node) {
        setNext(new DoubleStreamProcessor(s.skip(node.getN())));
    }

    public void sorted(SD_Sorted node) {
        setNext(new DoubleStreamProcessor(s.sorted()));
    }

    public void spliterator(SDT_Spliterator node) {
        setResult(s.spliterator());
    }

    public void sum(SDT_Sum node) {
        setResult(s.sum());
    }

    public void summaryStatistics(SDT_SummaryStatistics node) {
        setResult(s.summaryStatistics());
    }

    public void toArray(SDT_ToArray node) {
        setResult(s.toArray());
    }

    public void unordered(SD_Unordered node) {
        setNext(new DoubleStreamProcessor(s.unordered()));
    }

    void process(QueryOperationNode node) {
        ((DoubleStreamVisitable) node).accept(this);
    }
}
