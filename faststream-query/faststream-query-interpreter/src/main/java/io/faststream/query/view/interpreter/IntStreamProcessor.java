/*
 * Copyright (c) 2008 Kasper Nielsen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* 
 * This class was automatically generated by cake.bootstrap.view.GenerateAll 
 * Available in the https://github.com/cakeframework/cake-developers/ project 
 */
package io.faststream.query.view.interpreter;

/**
 * This class has been autogenerated
 *
 * @author Kasper Nielsen
 */
import java.util.Objects;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.stream.IntStream;

import io.faststream.query.db.nodes.stream.intstream.IntStreamVisitable;
import io.faststream.query.db.nodes.stream.intstream.SIT_AllMatch;
import io.faststream.query.db.nodes.stream.intstream.SIT_AnyMatch;
import io.faststream.query.db.nodes.stream.intstream.SIT_Average;
import io.faststream.query.db.nodes.stream.intstream.SIT_Collect;
import io.faststream.query.db.nodes.stream.intstream.SIT_Count;
import io.faststream.query.db.nodes.stream.intstream.SIT_FindAny;
import io.faststream.query.db.nodes.stream.intstream.SIT_FindFirst;
import io.faststream.query.db.nodes.stream.intstream.SIT_ForEach;
import io.faststream.query.db.nodes.stream.intstream.SIT_ForEachOrdered;
import io.faststream.query.db.nodes.stream.intstream.SIT_Iterator;
import io.faststream.query.db.nodes.stream.intstream.SIT_Max;
import io.faststream.query.db.nodes.stream.intstream.SIT_Min;
import io.faststream.query.db.nodes.stream.intstream.SIT_NoneMatch;
import io.faststream.query.db.nodes.stream.intstream.SIT_Reduce;
import io.faststream.query.db.nodes.stream.intstream.SIT_Spliterator;
import io.faststream.query.db.nodes.stream.intstream.SIT_Sum;
import io.faststream.query.db.nodes.stream.intstream.SIT_SummaryStatistics;
import io.faststream.query.db.nodes.stream.intstream.SIT_ToArray;
import io.faststream.query.db.nodes.stream.intstream.SI_AsDoubleStream;
import io.faststream.query.db.nodes.stream.intstream.SI_AsLongStream;
import io.faststream.query.db.nodes.stream.intstream.SI_Boxed;
import io.faststream.query.db.nodes.stream.intstream.SI_Distinct;
import io.faststream.query.db.nodes.stream.intstream.SI_Filter;
import io.faststream.query.db.nodes.stream.intstream.SI_FlatMap;
import io.faststream.query.db.nodes.stream.intstream.SI_Limit;
import io.faststream.query.db.nodes.stream.intstream.SI_Map;
import io.faststream.query.db.nodes.stream.intstream.SI_MapToDouble;
import io.faststream.query.db.nodes.stream.intstream.SI_MapToLong;
import io.faststream.query.db.nodes.stream.intstream.SI_MapToObj;
import io.faststream.query.db.nodes.stream.intstream.SI_Parallel;
import io.faststream.query.db.nodes.stream.intstream.SI_Peek;
import io.faststream.query.db.nodes.stream.intstream.SI_Sequential;
import io.faststream.query.db.nodes.stream.intstream.SI_Skip;
import io.faststream.query.db.nodes.stream.intstream.SI_Sorted;
import io.faststream.query.db.nodes.stream.intstream.SI_Unordered;
import io.faststream.query.db.query.node.EmptyResult;
import io.faststream.query.db.query.node.QueryOperationNode;

@SuppressWarnings("unchecked" )
public class IntStreamProcessor extends AbstractSingleNodeViewQueryProcessor implements IntStreamVisitable.IntStreamVisitor {

    private final IntStream s;

    public IntStreamProcessor(IntStream s) {
        this.s = Objects.requireNonNull(s);
    }

    public void allMatch(SIT_AllMatch node) {
        setResult(s.allMatch(node.getIntPredicate()));
    }

    public void anyMatch(SIT_AnyMatch node) {
        setResult(s.anyMatch(node.getIntPredicate()));
    }

    public void asDoubleStream(SI_AsDoubleStream node) {
        setNext(new DoubleStreamProcessor(s.asDoubleStream()));
    }

    public void asLongStream(SI_AsLongStream node) {
        setNext(new LongStreamProcessor(s.asLongStream()));
    }

    public void average(SIT_Average node) {
        OptionalDouble opt = s.average();
        setResult(opt.isPresent() ? opt.getAsDouble() : EmptyResult.EMPTY_RESULT);
    }

    public void boxed(SI_Boxed node) {
        setNext(new StreamProcessor(s.boxed()));
    }

    public void collect(SIT_Collect node) {
        setResult(s.collect(node.getSupplier(), node.getObjIntConsumer(), node.getBiConsumer()));
    }

    public void count(SIT_Count node) {
        setResult(s.count());
    }

    public void distinct(SI_Distinct node) {
        setNext(new IntStreamProcessor(s.distinct()));
    }

    public void filter(SI_Filter node) {
        setNext(new IntStreamProcessor(s.filter(node.getIntPredicate())));
    }

    public void findAny(SIT_FindAny node) {
        OptionalInt opt = s.findAny();
        setResult(opt.isPresent() ? opt.getAsInt() : EmptyResult.EMPTY_RESULT);
    }

    public void findFirst(SIT_FindFirst node) {
        OptionalInt opt = s.findFirst();
        setResult(opt.isPresent() ? opt.getAsInt() : EmptyResult.EMPTY_RESULT);
    }

    public void flatMap(SI_FlatMap node) {
        setNext(new IntStreamProcessor(s.flatMap(node.getMapper())));
    }

    public void forEach(SIT_ForEach node) {
        s.forEach(node.getAction());
        setResult(null);
    }

    public void forEachOrdered(SIT_ForEachOrdered node) {
        s.forEachOrdered(node.getAction());
        setResult(null);
    }

    public void iterator(SIT_Iterator node) {
        setResult(s.iterator());
    }

    public void limit(SI_Limit node) {
        setNext(new IntStreamProcessor(s.limit(node.getMaxSize())));
    }

    public void map(SI_Map node) {
        setNext(new IntStreamProcessor(s.map(node.getIntUnaryOperator())));
    }

    public void mapToDouble(SI_MapToDouble node) {
        setNext(new DoubleStreamProcessor(s.mapToDouble(node.getMapper())));
    }

    public void mapToLong(SI_MapToLong node) {
        setNext(new LongStreamProcessor(s.mapToLong(node.getMapper())));
    }

    public void mapToObj(SI_MapToObj node) {
        setNext(new StreamProcessor(s.mapToObj(node.getMapper())));
    }

    public void max(SIT_Max node) {
        OptionalInt opt = s.max();
        setResult(opt.isPresent() ? opt.getAsInt() : EmptyResult.EMPTY_RESULT);
    }

    public void min(SIT_Min node) {
        OptionalInt opt = s.min();
        setResult(opt.isPresent() ? opt.getAsInt() : EmptyResult.EMPTY_RESULT);
    }

    public void noneMatch(SIT_NoneMatch node) {
        setResult(s.noneMatch(node.getIntPredicate()));
    }

    public void parallel(SI_Parallel node) {
        setNext(new IntStreamProcessor(s.parallel()));
    }

    public void peek(SI_Peek node) {
        setNext(new IntStreamProcessor(s.peek(node.getIntConsumer())));
    }

    public void reduce(SIT_Reduce node) {
        OptionalInt opt = s.reduce(node.getOp());
        setResult(opt.isPresent() ? opt.getAsInt() : EmptyResult.EMPTY_RESULT);
    }

    public void sequential(SI_Sequential node) {
        setNext(new IntStreamProcessor(s.sequential()));
    }

    public void skip(SI_Skip node) {
        setNext(new IntStreamProcessor(s.skip(node.getN())));
    }

    public void sorted(SI_Sorted node) {
        setNext(new IntStreamProcessor(s.sorted()));
    }

    public void spliterator(SIT_Spliterator node) {
        setResult(s.spliterator());
    }

    public void sum(SIT_Sum node) {
        setResult(s.sum());
    }

    public void summaryStatistics(SIT_SummaryStatistics node) {
        setResult(s.summaryStatistics());
    }

    public void toArray(SIT_ToArray node) {
        setResult(s.toArray());
    }

    public void unordered(SI_Unordered node) {
        setNext(new IntStreamProcessor(s.unordered()));
    }

    void process(QueryOperationNode node) {
        ((IntStreamVisitable) node).accept(this);
    }
}
