/*
 * Copyright (c) 2008 Kasper Nielsen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* 
 * This class was automatically generated by cake.bootstrap.view.GenerateAll 
 * Available in the https://github.com/cakeframework/cake-developers/ project 
 */
package org.cakeframework.internal.view.interpreter;

/**
 * This class has been autogenerated
 *
 * @author Kasper Nielsen
 */
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;

import org.cakeframework.internal.db.nodes.stream.stream.SOT_AllMatch;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_AnyMatch;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_Collect;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_CollectSupplier;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_Count;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_FindAny;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_FindFirst;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_ForEach;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_ForEachOrdered;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_Iterator;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_MaxComparator;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_MinComparator;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_NoneMatch;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_Reduce;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_ReduceCombiner;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_Spliterator;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_ToArray;
import org.cakeframework.internal.db.nodes.stream.stream.SOT_ToArrayFunction;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Distinct;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Filter;
import org.cakeframework.internal.db.nodes.stream.stream.SO_FlatMap;
import org.cakeframework.internal.db.nodes.stream.stream.SO_FlatMapToDouble;
import org.cakeframework.internal.db.nodes.stream.stream.SO_FlatMapToInt;
import org.cakeframework.internal.db.nodes.stream.stream.SO_FlatMapToLong;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Limit;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Map;
import org.cakeframework.internal.db.nodes.stream.stream.SO_MapToDouble;
import org.cakeframework.internal.db.nodes.stream.stream.SO_MapToInt;
import org.cakeframework.internal.db.nodes.stream.stream.SO_MapToLong;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Parallel;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Peek;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Sequential;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Skip;
import org.cakeframework.internal.db.nodes.stream.stream.SO_SortedAscending;
import org.cakeframework.internal.db.nodes.stream.stream.SO_SortedComparator;
import org.cakeframework.internal.db.nodes.stream.stream.SO_Unordered;
import org.cakeframework.internal.db.nodes.stream.stream.StreamVisitable;
import org.cakeframework.internal.db.query.node.EmptyResult;
import org.cakeframework.internal.db.query.node.QueryOperationNode;

@SuppressWarnings({"rawtypes", "unchecked" })
public class StreamProcessor extends AbstractSingleNodeViewQueryProcessor implements StreamVisitable.StreamVisitor {

    private final Stream s;

    public StreamProcessor(Stream s) {
        this.s = Objects.requireNonNull(s);
    }

    public void allMatch(SOT_AllMatch node) {
        setResult(s.allMatch(node.getPredicate()));
    }

    public void anyMatch(SOT_AnyMatch node) {
        setResult(s.anyMatch(node.getPredicate()));
    }

    public void collect(SOT_Collect node) {
        setResult(s.collect(node.getCollector()));
    }

    public void collectSupplier(SOT_CollectSupplier node) {
        setResult(s.collect(node.getSupplier(), node.getAccumulator(), node.getCombiner()));
    }

    public void count(SOT_Count node) {
        setResult(s.count());
    }

    public void distinct(SO_Distinct node) {
        setNext(new StreamProcessor(s.distinct()));
    }

    public void filter(SO_Filter node) {
        setNext(new StreamProcessor(s.filter(node.getPredicate())));
    }

    public void findAny(SOT_FindAny node) {
        Optional opt = s.findAny();
        setResult(opt.isPresent() ? opt.get() : EmptyResult.EMPTY_RESULT);
    }

    public void findFirst(SOT_FindFirst node) {
        Optional opt = s.findFirst();
        setResult(opt.isPresent() ? opt.get() : EmptyResult.EMPTY_RESULT);
    }

    public void flatMap(SO_FlatMap node) {
        setNext(new StreamProcessor(s.flatMap(node.getMapper())));
    }

    public void flatMapToDouble(SO_FlatMapToDouble node) {
        setNext(new DoubleStreamProcessor(s.flatMapToDouble(node.getMapper())));
    }

    public void flatMapToInt(SO_FlatMapToInt node) {
        setNext(new IntStreamProcessor(s.flatMapToInt(node.getMapper())));
    }

    public void flatMapToLong(SO_FlatMapToLong node) {
        setNext(new LongStreamProcessor(s.flatMapToLong(node.getMapper())));
    }

    public void forEach(SOT_ForEach node) {
        s.forEach(node.getAction());
        setResult(null);
    }

    public void forEachOrdered(SOT_ForEachOrdered node) {
        s.forEachOrdered(node.getAction());
        setResult(null);
    }

    public void iterator(SOT_Iterator node) {
        setResult(s.iterator());
    }

    public void limit(SO_Limit node) {
        setNext(new StreamProcessor(s.limit(node.getMaxSize())));
    }

    public void map(SO_Map node) {
        setNext(new StreamProcessor(s.map(node.getMapper())));
    }

    public void mapToDouble(SO_MapToDouble node) {
        setNext(new DoubleStreamProcessor(s.mapToDouble(node.getMapper())));
    }

    public void mapToInt(SO_MapToInt node) {
        setNext(new IntStreamProcessor(s.mapToInt(node.getMapper())));
    }

    public void mapToLong(SO_MapToLong node) {
        setNext(new LongStreamProcessor(s.mapToLong(node.getMapper())));
    }

    public void maxComparator(SOT_MaxComparator node) {
        Optional opt = s.max(node.getComparator());
        setResult(opt.isPresent() ? opt.get() : EmptyResult.EMPTY_RESULT);
    }

    public void minComparator(SOT_MinComparator node) {
        Optional opt = s.min(node.getComparator());
        setResult(opt.isPresent() ? opt.get() : EmptyResult.EMPTY_RESULT);
    }

    public void noneMatch(SOT_NoneMatch node) {
        setResult(s.noneMatch(node.getPredicate()));
    }

    public void parallel(SO_Parallel node) {
        setNext(new StreamProcessor((Stream) s.parallel()));
    }

    public void peek(SO_Peek node) {
        setNext(new StreamProcessor(s.peek(node.getConsumer())));
    }

    public void reduce(SOT_Reduce node) {
        Optional opt = s.reduce(node.getAccumulator());
        setResult(opt.isPresent() ? opt.get() : EmptyResult.EMPTY_RESULT);
    }

    public void reduceCombiner(SOT_ReduceCombiner node) {
        setResult(s.reduce(node.getIdentity(), node.getAccumulator(), node.getCombiner()));
    }

    public void sequential(SO_Sequential node) {
        setNext(new StreamProcessor((Stream) s.sequential()));
    }

    public void skip(SO_Skip node) {
        setNext(new StreamProcessor(s.skip(node.getN())));
    }

    public void sortedAscending(SO_SortedAscending node) {
        setNext(new StreamProcessor(s.sorted()));
    }

    public void sortedComparator(SO_SortedComparator node) {
        setNext(new StreamProcessor(s.sorted(node.getComparator())));
    }

    public void spliterator(SOT_Spliterator node) {
        setResult(s.spliterator());
    }

    public void toArray(SOT_ToArray node) {
        setResult(s.toArray());
    }

    public void toArrayFunction(SOT_ToArrayFunction node) {
        setResult(s.toArray(node.getGenerator()));
    }

    public void unordered(SO_Unordered node) {
        setNext(new StreamProcessor((Stream) s.unordered()));
    }

    void process(QueryOperationNode node) {
        ((StreamVisitable) node).accept(this);
    }
}
