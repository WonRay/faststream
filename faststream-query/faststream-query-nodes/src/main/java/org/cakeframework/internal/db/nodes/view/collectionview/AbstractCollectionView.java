/*
 * Copyright (c) 2008 Kasper Nielsen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* 
 * This class was automatically generated by cake.bootstrap.view.GenerateAll 
 * Available in the https://github.com/cakeframework/cake-developers/ project 
 */
package org.cakeframework.internal.db.nodes.view.collectionview;

/**
 * This class has been autogenerated
 *
 * @author Kasper Nielsen
 */
import java.util.Comparator;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.function.BinaryOperator;
import java.util.function.Consumer;
import java.util.function.Function;
import java.util.function.Predicate;
import java.util.function.Supplier;
import java.util.stream.Stream;

import org.cakeframework.internal.db.query.node.EmptyResult;
import org.cakeframework.internal.db.query.node.QueryOperationNode;
import org.cakeframework.internal.db.query.node.QueryOperationNodeDefinition;
import org.cakeframework.internal.db.query.node.TerminalQueryOperationNodeProcessor;
import org.cakeframework.util.view.CollectionView;
import org.cakeframework.util.view.MapView;
import org.cakeframework.util.view.MultimapView;

@SuppressWarnings({"rawtypes", "unchecked" })
public abstract class AbstractCollectionView extends QueryOperationNode implements CollectionView {

    private static final long serialVersionUID = 1L;

    public AbstractCollectionView(QueryOperationNode previous) {
        super(previous);
    }

    public AbstractCollectionView(TerminalQueryOperationNodeProcessor processor) {
        super(processor);
    }

    public Object any() {
        Object result = new CVT_Any(this).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            throw new NoSuchElementException();
        }
        return result;
    }

    public Object any(Object base) {
        Object result = new CVT_Any(this).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return base;
        }
        return result;
    }

    public Stream asStream() {
        return new CV_AsStream(this);
    }

    public MapView count() {
        return new CV_Count(this);
    }

    public CollectionView distinct() {
        return new CV_Distinct(this);
    }

    public CollectionView filter(Predicate predicate) {
        return new CV_Filter(this, predicate);
    }

    public CollectionView filterNulls() {
        return new CV_FilterNulls(this);
    }

    public CollectionView filterOnType(Class clazz) {
        return new CV_FilterOnType(this, clazz);
    }

    public Object first() {
        Object result = new CVT_First(this).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            throw new NoSuchElementException();
        }
        return result;
    }

    public Object first(Object base) {
        Object result = new CVT_First(this).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return base;
        }
        return result;
    }

    public void forEach(Consumer consumer) {
        new CVT_ForEach(this, consumer).process();
    }

    public CollectionView gather(Supplier gatherer) {
        return new CV_Gather(this, gatherer);
    }

    public MultimapView groupBy(Function mapper) {
        return new CV_GroupBy(this, mapper);
    }

    public boolean isEmpty() {
        return (Boolean) new CVT_IsEmpty(this).process();
    }

    public Object last() {
        Object result = new CVT_Last(this).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            throw new NoSuchElementException();
        }
        return result;
    }

    public Object last(Object base) {
        Object result = new CVT_Last(this).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return base;
        }
        return result;
    }

    public CollectionView map(Function mapper) {
        return new CV_Map(this, mapper);
    }

    public MapView mapToIndex() {
        return new CV_MapToIndex(this);
    }

    public Object one() {
        Object result = new CVT_One(this).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            throw new NoSuchElementException();
        }
        return result;
    }

    public Object one(Object base) {
        Object result = new CVT_One(this).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return base;
        }
        return result;
    }

    public Object reduce(BinaryOperator reducer) {
        Object result = new CVT_Reduce(this, reducer).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            throw new IllegalStateException();
        }
        return result;
    }

    public Object reduce(Object base, BinaryOperator reducer) {
        Object result = new CVT_Reduce(this, reducer).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return base;
        }
        return result;
    }

    public CollectionView reverse() {
        return new CV_Reverse(this);
    }

    public CollectionView shuffle() {
        return new CV_Shuffle(this);
    }

    public long size() {
        return (Long) new CVT_Size(this).process();
    }

    public CollectionView sorted() {
        return new CV_SortedAscending(this);
    }

    public CollectionView sorted(Comparator comparator) {
        return new CV_Sorted(this, comparator);
    }

    public CollectionView sortedDescending() {
        return new CV_SortedDescending(this);
    }

    public CollectionView take(long numberOfElementsToTake) {
        return new CV_Take(this, numberOfElementsToTake);
    }

    public Object to(Class type) {
        return new CVT_To(this, type).process();
    }

    public List toList() {
        return (List) new CVT_ToList(this).process();
    }

    public static <E> CollectionView<E> from(TerminalQueryOperationNodeProcessor processor) {
        return new DefaultCollectionView(processor);
    }

    static final class DefaultCollectionView extends AbstractCollectionView {

        private static final long serialVersionUID = 1L;

        DefaultCollectionView(TerminalQueryOperationNodeProcessor processor) {
            super(processor);
        }

        public final int getNodeId() {
            return -1;
        }

        @Override
        public final int getNodeType() {
            return 1;
        }

        @Override
        public final String name() {
            return "root";
        }

        @Override
        public final QueryOperationNodeDefinition getOperationPackage() {
            return null;
        }
    }
}
