/*
 * Copyright (c) 2008 Kasper Nielsen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* 
 * This class was automatically generated by cake.bootstrap.view.GenerateAll 
 * Available in the https://github.com/cakeframework/cake-developers/ project 
 */
package io.faststream.query.db.nodes.stream.intstream;

/**
 * This class has been autogenerated
 *
 * @author Kasper Nielsen
 */
import java.util.IntSummaryStatistics;
import java.util.OptionalDouble;
import java.util.OptionalInt;
import java.util.PrimitiveIterator;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.IntBinaryOperator;
import java.util.function.IntConsumer;
import java.util.function.IntFunction;
import java.util.function.IntPredicate;
import java.util.function.IntToDoubleFunction;
import java.util.function.IntToLongFunction;
import java.util.function.IntUnaryOperator;
import java.util.function.ObjIntConsumer;
import java.util.function.Supplier;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

import io.faststream.query.db.nodes.stream.StreamContext;
import io.faststream.query.db.query.node.EmptyResult;
import io.faststream.query.db.query.node.QueryOperationNode;
import io.faststream.query.db.query.node.QueryOperationNodeDefinition;
import io.faststream.query.db.query.node.TerminalQueryOperationNodeProcessor;

@SuppressWarnings({"rawtypes", "unchecked" })
public abstract class AbstractIntStream extends QueryOperationNode implements IntStream {

    private static final long serialVersionUID = 1L;

    private final StreamContext context;

    public AbstractIntStream(QueryOperationNode previous, StreamContext context) {
        super(previous);
        this.context = context;
    }

    public AbstractIntStream(TerminalQueryOperationNodeProcessor processor) {
        super(processor);
        this.context = new StreamContext();
    }

    public boolean allMatch(IntPredicate intPredicate) {
        return (Boolean) new SIT_AllMatch(this, context, intPredicate).process();
    }

    public boolean anyMatch(IntPredicate intPredicate) {
        return (Boolean) new SIT_AnyMatch(this, context, intPredicate).process();
    }

    public DoubleStream asDoubleStream() {
        return new SI_AsDoubleStream(this, context);
    }

    public LongStream asLongStream() {
        return new SI_AsLongStream(this, context);
    }

    public OptionalDouble average() {
        Object result = new SIT_Average(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalDouble.empty();
        }
        return OptionalDouble.of((Double) result);
    }

    public Stream boxed() {
        return new SI_Boxed(this, context);
    }

    public void close() {
        context.close();
    }

    public Object collect(Supplier supplier, ObjIntConsumer objIntConsumer, BiConsumer biConsumer) {
        return new SIT_Collect(this, context, supplier, objIntConsumer, biConsumer).process();
    }

    public long count() {
        return (Long) new SIT_Count(this, context).process();
    }

    public IntStream distinct() {
        return new SI_Distinct(this, context);
    }

    public IntStream filter(IntPredicate intPredicate) {
        return new SI_Filter(this, context, intPredicate);
    }

    public OptionalInt findAny() {
        Object result = new SIT_FindAny(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalInt.empty();
        }
        return OptionalInt.of((Integer) result);
    }

    public OptionalInt findFirst() {
        Object result = new SIT_FindFirst(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalInt.empty();
        }
        return OptionalInt.of((Integer) result);
    }

    public IntStream flatMap(IntFunction mapper) {
        return new SI_FlatMap(this, context, mapper);
    }

    public void forEach(IntConsumer action) {
        new SIT_ForEach(this, context, action).process();
    }

    public void forEachOrdered(IntConsumer action) {
        new SIT_ForEachOrdered(this, context, action).process();
    }

    public boolean isParallel() {
        return false;
    }

    public PrimitiveIterator.OfInt iterator() {
        return (PrimitiveIterator.OfInt) new SIT_Iterator(this, context).process();
    }

    public IntStream limit(long maxSize) {
        return new SI_Limit(this, context, maxSize);
    }

    public IntStream map(IntUnaryOperator intUnaryOperator) {
        return new SI_Map(this, context, intUnaryOperator);
    }

    public DoubleStream mapToDouble(IntToDoubleFunction mapper) {
        return new SI_MapToDouble(this, context, mapper);
    }

    public LongStream mapToLong(IntToLongFunction mapper) {
        return new SI_MapToLong(this, context, mapper);
    }

    public Stream mapToObj(IntFunction mapper) {
        return new SI_MapToObj(this, context, mapper);
    }

    public OptionalInt max() {
        Object result = new SIT_Max(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalInt.empty();
        }
        return OptionalInt.of((Integer) result);
    }

    public OptionalInt min() {
        Object result = new SIT_Min(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalInt.empty();
        }
        return OptionalInt.of((Integer) result);
    }

    public boolean noneMatch(IntPredicate intPredicate) {
        return (Boolean) new SIT_NoneMatch(this, context, intPredicate).process();
    }

    public IntStream onClose(Runnable runnable) {
        context.onClose(runnable);
        return this;
    }

    public IntStream parallel() {
        return new SI_Parallel(this, context);
    }

    public IntStream peek(IntConsumer intConsumer) {
        return new SI_Peek(this, context, intConsumer);
    }

    public OptionalInt reduce(IntBinaryOperator op) {
        Object result = new SIT_Reduce(this, context, op).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalInt.empty();
        }
        return OptionalInt.of((Integer) result);
    }

    public int reduce(int identity, IntBinaryOperator op) {
        Object result = new SIT_Reduce(this, context, op).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return identity;
        }
        return (Integer) result;
    }

    public IntStream sequential() {
        return new SI_Sequential(this, context);
    }

    public IntStream skip(long n) {
        return new SI_Skip(this, context, n);
    }

    public IntStream sorted() {
        return new SI_Sorted(this, context);
    }

    public Spliterator.OfInt spliterator() {
        return (Spliterator.OfInt) new SIT_Spliterator(this, context).process();
    }

    public int sum() {
        return (Integer) new SIT_Sum(this, context).process();
    }

    public IntSummaryStatistics summaryStatistics() {
        return (IntSummaryStatistics) new SIT_SummaryStatistics(this, context).process();
    }

    public int[] toArray() {
        return (int[]) new SIT_ToArray(this, context).process();
    }

    public IntStream unordered() {
        return new SI_Unordered(this, context);
    }

    public static  IntStream from(TerminalQueryOperationNodeProcessor processor) {
        return new DefaultIntStream(processor);
    }

    static final class DefaultIntStream extends AbstractIntStream {

        private static final long serialVersionUID = 1L;

        DefaultIntStream(TerminalQueryOperationNodeProcessor processor) {
            super(processor);
        }

        public final int getNodeId() {
            return -3;
        }

        @Override
        public final int getNodeType() {
            return 3;
        }

        @Override
        public final String name() {
            return "root";
        }

        @Override
        public final QueryOperationNodeDefinition getOperationPackage() {
            return null;
        }
    }
}
