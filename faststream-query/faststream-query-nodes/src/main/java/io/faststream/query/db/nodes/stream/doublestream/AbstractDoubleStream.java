/*
 * Copyright (c) 2008 Kasper Nielsen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* 
 * This class was automatically generated by cake.bootstrap.view.GenerateAll 
 * Available in the https://github.com/cakeframework/cake-developers/ project 
 */
package io.faststream.query.db.nodes.stream.doublestream;

/**
 * This class has been autogenerated
 *
 * @author Kasper Nielsen
 */
import java.util.DoubleSummaryStatistics;
import java.util.OptionalDouble;
import java.util.PrimitiveIterator;
import java.util.Spliterator;
import java.util.function.BiConsumer;
import java.util.function.DoubleBinaryOperator;
import java.util.function.DoubleConsumer;
import java.util.function.DoubleFunction;
import java.util.function.DoublePredicate;
import java.util.function.DoubleToIntFunction;
import java.util.function.DoubleToLongFunction;
import java.util.function.DoubleUnaryOperator;
import java.util.function.ObjDoubleConsumer;
import java.util.function.Supplier;
import java.util.stream.DoubleStream;
import java.util.stream.IntStream;
import java.util.stream.LongStream;
import java.util.stream.Stream;

import io.faststream.query.db.nodes.stream.StreamContext;
import io.faststream.query.db.query.node.EmptyResult;
import io.faststream.query.db.query.node.QueryOperationNode;
import io.faststream.query.db.query.node.QueryOperationNodeDefinition;
import io.faststream.query.db.query.node.TerminalQueryOperationNodeProcessor;

@SuppressWarnings({"rawtypes", "unchecked" })
public abstract class AbstractDoubleStream extends QueryOperationNode implements DoubleStream {

    private static final long serialVersionUID = 1L;

    private final StreamContext context;

    public AbstractDoubleStream(QueryOperationNode previous, StreamContext context) {
        super(previous);
        this.context = context;
    }

    public AbstractDoubleStream(TerminalQueryOperationNodeProcessor processor) {
        super(processor);
        this.context = new StreamContext();
    }

    public boolean allMatch(DoublePredicate doublePredicate) {
        return (Boolean) new SDT_AllMatch(this, context, doublePredicate).process();
    }

    public boolean anyMatch(DoublePredicate doublePredicate) {
        return (Boolean) new SDT_AnyMatch(this, context, doublePredicate).process();
    }

    public OptionalDouble average() {
        Object result = new SDT_Average(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalDouble.empty();
        }
        return OptionalDouble.of((Double) result);
    }

    public Stream boxed() {
        return new SD_Boxed(this, context);
    }

    public void close() {
        context.close();
    }

    public Object collect(Supplier supplier, ObjDoubleConsumer objDoubleConsumer, BiConsumer biConsumer) {
        return new SDT_Collect(this, context, supplier, objDoubleConsumer, biConsumer).process();
    }

    public long count() {
        return (Long) new SDT_Count(this, context).process();
    }

    public DoubleStream distinct() {
        return new SD_Distinct(this, context);
    }

    public DoubleStream filter(DoublePredicate doublePredicate) {
        return new SD_Filter(this, context, doublePredicate);
    }

    public OptionalDouble findAny() {
        Object result = new SDT_FindAny(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalDouble.empty();
        }
        return OptionalDouble.of((Double) result);
    }

    public OptionalDouble findFirst() {
        Object result = new SDT_FindFirst(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalDouble.empty();
        }
        return OptionalDouble.of((Double) result);
    }

    public DoubleStream flatMap(DoubleFunction mapper) {
        return new SD_FlatMap(this, context, mapper);
    }

    public void forEach(DoubleConsumer action) {
        new SDT_ForEach(this, context, action).process();
    }

    public void forEachOrdered(DoubleConsumer action) {
        new SDT_ForEachOrdered(this, context, action).process();
    }

    public boolean isParallel() {
        return false;
    }

    public PrimitiveIterator.OfDouble iterator() {
        return (PrimitiveIterator.OfDouble) new SDT_Iterator(this, context).process();
    }

    public DoubleStream limit(long maxSize) {
        return new SD_Limit(this, context, maxSize);
    }

    public DoubleStream map(DoubleUnaryOperator doubleUnaryOperator) {
        return new SD_Map(this, context, doubleUnaryOperator);
    }

    public IntStream mapToInt(DoubleToIntFunction mapper) {
        return new SD_MapToInt(this, context, mapper);
    }

    public LongStream mapToLong(DoubleToLongFunction mapper) {
        return new SD_MapToLong(this, context, mapper);
    }

    public Stream mapToObj(DoubleFunction mapper) {
        return new SD_MapToObj(this, context, mapper);
    }

    public OptionalDouble max() {
        Object result = new SDT_Max(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalDouble.empty();
        }
        return OptionalDouble.of((Double) result);
    }

    public OptionalDouble min() {
        Object result = new SDT_Min(this, context).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalDouble.empty();
        }
        return OptionalDouble.of((Double) result);
    }

    public boolean noneMatch(DoublePredicate doublePredicate) {
        return (Boolean) new SDT_NoneMatch(this, context, doublePredicate).process();
    }

    public DoubleStream onClose(Runnable runnable) {
        context.onClose(runnable);
        return this;
    }

    public DoubleStream parallel() {
        return new SD_Parallel(this, context);
    }

    public DoubleStream peek(DoubleConsumer doubleConsumer) {
        return new SD_Peek(this, context, doubleConsumer);
    }

    public OptionalDouble reduce(DoubleBinaryOperator op) {
        Object result = new SDT_Reduce(this, context, op).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return OptionalDouble.empty();
        }
        return OptionalDouble.of((Double) result);
    }

    public double reduce(double identity, DoubleBinaryOperator op) {
        Object result = new SDT_Reduce(this, context, op).process();
        if (result == EmptyResult.EMPTY_RESULT) {
            return identity;
        }
        return (Double) result;
    }

    public DoubleStream sequential() {
        return new SD_Sequential(this, context);
    }

    public DoubleStream skip(long n) {
        return new SD_Skip(this, context, n);
    }

    public DoubleStream sorted() {
        return new SD_Sorted(this, context);
    }

    public Spliterator.OfDouble spliterator() {
        return (Spliterator.OfDouble) new SDT_Spliterator(this, context).process();
    }

    public double sum() {
        return (Double) new SDT_Sum(this, context).process();
    }

    public DoubleSummaryStatistics summaryStatistics() {
        return (DoubleSummaryStatistics) new SDT_SummaryStatistics(this, context).process();
    }

    public double[] toArray() {
        return (double[]) new SDT_ToArray(this, context).process();
    }

    public DoubleStream unordered() {
        return new SD_Unordered(this, context);
    }

    public static  DoubleStream from(TerminalQueryOperationNodeProcessor processor) {
        return new DefaultDoubleStream(processor);
    }

    static final class DefaultDoubleStream extends AbstractDoubleStream {

        private static final long serialVersionUID = 1L;

        DefaultDoubleStream(TerminalQueryOperationNodeProcessor processor) {
            super(processor);
        }

        public final int getNodeId() {
            return -5;
        }

        @Override
        public final int getNodeType() {
            return 5;
        }

        @Override
        public final String name() {
            return "root";
        }

        @Override
        public final QueryOperationNodeDefinition getOperationPackage() {
            return null;
        }
    }
}
